% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FINNInterface.R
\name{finn}
\alias{finn}
\title{Forest informed neural network}
\usage{
finn(
  data = NULL,
  env,
  disturbance = NULL,
  mortalityProcess = NULL,
  growthProcess = NULL,
  regenerationProcess = NULL,
  competitionProcess = NULL,
  height = NULL,
  optimizeHeight = FALSE,
  speciesPars_ranges = list(parGrowth = rbind(c(0.01, 0.99), c(0.01, 4)), parMort =
    rbind(c(0.01, 0.99), c(0, 4)), parReg = c(0.01, 0.99), parHeight = c(0.3, 0.7),
    parGrowthEnv = rbind(c(-1, 1), c(-1, 1)), parMortEnv = rbind(c(-2, 2), c(-2, 2)),
    parRegEnv = rbind(c(-2, 2), c(-2, 2))),
  patches = 10L,
  patch_size = 0.1,
  init = NULL,
  batchsize = NULL,
  epochs = 20L,
  lr = 0.1,
  device = c("cpu", "gpu"),
  bootstrap = NULL,
  parallel = FALSE,
  NGPU = 1,
  weights = c(0.05, 0.5, 3, 0.5, 3, 2),
  file = NULL,
  ...
)
}
\arguments{
\item{data}{(\code{data.table}) \cr
Data containing species information, must include the columns siteID, species, year, dbh, ba, trees, AL, growth, mort, and reg.}

\item{env}{(\code{data.table}) \cr
Data containing environmental predictors, must include the columns siteID, year, and names of environmental predictors used in the formula argument of the processes.}

\item{disturbance}{(\code{data.table}) \cr
Data containing disturbance events, must include the columns siteID, year, and intensity.}

\item{mortalityProcess}{(\code{NULL}, \code{formula}, or \code{process} created by \code{createProcess()}) \cr
A process object or formula defining the mortality process. If \code{NULL}, default \code{createProcess(...)} object will be used (all envrionmental predictors will be used).}

\item{growthProcess}{(\code{NULL}, \code{formula}, or \code{process} created by \code{createProcess()}) \cr
A process object or formula defining the growth process. If \code{NULL}, default \code{createProcess(...)} object will be used (all envrionmental predictors will be used).}

\item{regenerationProcess}{(\code{NULL}, \code{formula}, or \code{process} created by \code{createProcess()}) \cr
A process object or formula defining the regeneration process. If \code{NULL}, default \code{createProcess(...)} object will be used (all envrionmental predictors will be used).}

\item{competitionProcess}{(\code{NULL}, \code{formula}, or \code{process} created by \code{createProcess()}) \cr
A function defining the competition process, if applicable. If \code{NULL}, default \code{createProcess(...)} object will be used.}

\item{height}{(\code{numeric(sp)}) \cr
Set of parameters defining the height-growth relationship, if applicable.}

\item{optimizeHeight}{(\code{logical(1)}) \cr
Should the height-growth parameters be estimated or not.}

\item{speciesPars_ranges}{(\code{list(parGrowth = list(matrix()), parMort = list(matrix()), parReg = list(matrix()), parHeight = list(matrix()))}) \cr
List of boundaries for species parameters.}

\item{patches}{(\code{integer(1)}) \cr
An integer specifying the number of patches in the simulation. Default is 10.}

\item{patch_size}{(\code{numeric(1)}) \cr
A numeric value representing the size of each patch. Default is 0.1.}

\item{init}{(\code{NULL} or \code{CohortMat} created by \code{CohortMat$new()}) \cr
A custom initialization object for the simulation, if available.}

\item{batchsize}{(\code{NULL} or \code{integer(1)}) \cr
batchsize (sites can be feed in chunkes to the predict function, can be necessary if GPU memory is limited).}

\item{epochs}{(\code{integer(1)}) \cr
Number of iteration (optimization) steps.}

\item{lr}{(\code{numeric(1)}) \cr
Learning rate for the first-gradient descent optimizer.}

\item{device}{(\code{character(1)}) \cr
A character string specifying whether to use \code{"cpu"} or \code{"gpu"} for computation. Default is \code{"cpu"}.}

\item{bootstrap}{(\code{logical(1)} or \code{integer(1)}) \cr
bootstrap model or not (computationally expensive!).}

\item{parallel}{(\code{character(1)}) \cr
A logical value indicating whether to run the bootstrapping in parallel. Default is \code{FALSE}.}

\item{NGPU}{(\code{character(1)}) \cr
An integer specifying the number of GPUs to use if \code{device = "gpu"}. Default is 1 (only used for parallel bootstrapping).}

\item{weights}{(\verb{numeric(6}) \cr
Weighting of the 6 errors (ba, trees, AL, growth, mortality, and regeneration).}

\item{file}{(\code{character()}) \cr
If weights should be saved after each optimization step (for monitoring), set a path. Default is \code{NULL}.}

\item{...}{arguments passed to \code{simulateForest()}}
}
\value{
A list of predicted values for each patch and species, containing arrays of tree diameters and tree counts.
}
\description{
\loadmathjax
This function is the main interface to the FINN platform. The function can be used to simulate and to estimate (fit) the parameters of the FINN model.
data
}
\details{
While FINN is a platform for modular dynamic forest models, we provide default functions for the four processes, namely \code{?mortality}, \code{?growth}, \code{?regeneration}, and \code{?competetition}.

The idea of finn is to combine mechanistic understanding (the processes) and data-driven approaches. Data-driven means that parameters of the model can be estimated (or informed) by empirical data. This is optional and can be realized in different ways or levels in finn. By default, we assume that the three processes mortality, growth, and regeneration depend on the environment (niche of species), available light (as a consequence of competition), and species specific parameters. The environmental component and the species specific parameters can be estimated or configured. The central function to configure each process is the \code{?createProcess} function.

In the \code{createProcess()} function, the parameters of the environmental model (by default a linear regression model) can be set by the \code{initEnv = ...} argument (must be a matrix with n rows for n species and m columns for m environmental predictors (which is set by the formula argument)). Species specific parameters are set by the \code{initSpecies=...} argument (check help of the default processes for dimensions). If \code{NULL} the parameters will be sampled from plausible ranges that serve as initial values for the optimization, if inference is desired (which is set by \code{optimizeSpecies} and \code{optimizeEnv} arguments). Moreover, custom process functions can be passed to the \code{createProcess()} function using the \code{func} argument. However, take caution that all operations in the custom process function are compatible with \code{torch}, work with multi-dimensional arrays, and are differentiable when inference is wanted. See the section below for more information about custom process functions.
\subsection{Custom Process Functions:}{

FINN is based on torch for R which is an library for Deep Learning. The advantage of torch is that all calculations are highly optimized and can be run on the GPU. To fully exploit the potential of GPU, all operations in FINN are based on multi-dimensional arrays, tensors. Usually, the dimensions of data objects within finn are of \mjseqn{[k_sites, m_{patches}, n_{cohorts}]}. For custom process functions to properly work, they must work on these tensors and handle the dimensions correctly (in the future we will provide helper functions to check automatically custom functions):

Part of the hybrid modeling example:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{growthCustom = function(dbh, species, parGrowth, pred, light, debug = F)\{
# dbh, species, light dimensions -> [sites, patches, cohorts]
# parGrowth species parameters, ignore
# pred -> [sites, number of environmental predictors]
input =
    torch::torch_cat(
      list(dbh$unsqueeze(4L)/200., # rescale dbh
           pred$unsqueeze(2L)$unsqueeze(2L)$`repeat`(c(1L, dbh$shape[2], dbh$shape[3], 1L)),
           light$unsqueeze(4L),
           torch::nnf_one_hot(species, num_classes = 3L)),
      dim = 4L)
  growth = self$nnGrowthEnv(input)[,,,1]$exp()
  return(growth)
\}
}\if{html}{\out{</div>}}

Within the custom growth function, the \code{torch::torch_cat()} function concatenates dbh, light, environment, and species information (one hot encoded species). The concatenation happens in an additional 4th dimension. \verb{$unsqueeze(dim = ..)} adds a new dimension at the specific dimension. For pred, we must add two additional dimensions and then repeat the values along these new dimensions to get the same number of patches and cohorts (\verb{dbh$shape[2], dbh$shape[3]}).

Moreover, the custom functions must be differentiable, in short, avoid complex R functions or functions from other packages, do not transform the tensors into R objects (e.g. by using \code{torch::as_array} or \code{as.matrix}), and be careful with indexing (we have helper functions for that (TODO!)).
}
}
